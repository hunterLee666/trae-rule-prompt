---
name: Task Decomposition Rules
description: 任务分解规则 - 复杂任务拆解、步骤规划、执行策略
version: "9.0"
priority: 90
alwaysApply: true
---

# 任务分解规则

> **"大事化小，小事化了。"**

## 一、任务复杂度评估

### 1.1 复杂度指标

```yaml
简单任务 (L1):
  特征: 单一操作，明确目标
  示例: 读取文件、搜索内容、简单查询
  步骤: 1-2步
  工具: 1个

中等任务 (L2):
  特征: 多步骤，有依赖关系
  示例: 代码重构、依赖分析、文档生成
  步骤: 3-5步
  工具: 2-3个

复杂任务 (L3):
  特征: 多模块协作，需要规划
  示例: 功能开发、架构重构、性能优化
  步骤: 5-10步
  工具: 3-5个

超复杂任务 (L4):
  特征: 开放式，需要迭代调整
  示例: 系统设计、问题诊断、创新方案
  步骤: 10+步
  工具: 5+个
```

### 1.2 复杂度评估算法

```yaml
评估维度:
  操作数量:
    1-2个操作: +1分
    3-5个操作: +2分
    6-10个操作: +3分
    10+个操作: +4分
    
  依赖关系:
    无依赖: +1分
    简单依赖: +2分
    复杂依赖: +3分
    
  不确定性:
    明确目标: +1分
    需要澄清: +2分
    开放式: +3分
    
  风险等级:
    低风险: +1分
    中风险: +2分
    高风险: +3分

复杂度计算:
  总分 4-6: L1简单任务
  总分 7-9: L2中等任务
  总分 10-12: L3复杂任务
  总分 13+: L4超复杂任务
```

---

## 二、任务分解策略

### 2.1 分解原则

```yaml
MECE原则:
  相互独立: 子任务之间不重叠
  完全穷尽: 所有子任务覆盖完整任务

粒度控制:
  最小粒度: 单一操作
  最大粒度: 可独立验证的单元
  推荐粒度: 3-5步可完成

依赖管理:
  串行依赖: 按顺序执行
  并行独立: 同时执行
  条件依赖: 根据条件执行
```

### 2.2 分解模式

```yaml
顺序分解:
  适用: 有明确执行顺序的任务
  模式: Task → Step1 → Step2 → Step3 → Result
  示例: 
    分析代码 → 读取文件 → 解析结构 → 生成报告

层次分解:
  适用: 有层次结构的任务
  模式: Task → SubTask1, SubTask2, SubTask3
  示例:
    重构项目 → 重构模块A → 重构模块B → 重构模块C

迭代分解:
  适用: 需要反复调整的任务
  模式: Task → Plan → Execute → Evaluate → Refine
  示例:
    优化性能 → 分析瓶颈 → 实施优化 → 测试效果 → 调整方案

分支分解:
  适用: 有多种可能路径的任务
  模式: Task → Condition → PathA | PathB
  示例:
    修复Bug → 定位问题 → 修复方案A | 修复方案B
```

### 2.3 分解模板

```yaml
标准分解模板:
  任务名称: [任务描述]
  复杂度: [L1-L4]
  
  子任务列表:
    - 子任务1:
        目标: [子任务目标]
        工具: [需要的工具]
        输入: [输入数据]
        输出: [预期输出]
        依赖: [依赖的子任务]
        
    - 子任务2:
        ...

  执行顺序: [顺序图]
  验证点: [检查点列表]
  回滚策略: [失败时的处理]
```

---

## 三、执行策略

### 3.1 执行模式

```yaml
顺序执行:
  条件: 子任务有严格依赖关系
  策略: 按顺序逐个执行
  优点: 简单可控
  缺点: 效率较低

并行执行:
  条件: 子任务相互独立
  策略: 同时执行多个子任务
  优点: 效率高
  缺点: 资源消耗大

混合执行:
  条件: 部分独立部分依赖
  策略: 独立的并行，依赖的串行
  优点: 平衡效率和可控性
  缺点: 调度复杂
```

### 3.2 执行控制

```yaml
进度跟踪:
  - 记录每个子任务状态
  - 计算整体完成进度
  - 预估剩余时间

错误处理:
  单点失败:
    策略: 停止执行，报告错误
    恢复: 修复后继续
    
  部分失败:
    策略: 跳过失败任务，继续其他
    恢复: 记录失败，后续处理
    
  级联失败:
    策略: 回滚已完成任务
    恢复: 重新规划执行

超时控制:
  单任务超时: 跳过或降级
  总任务超时: 终止并报告进度
```

### 3.3 验证机制

```yaml
阶段验证:
  每个子任务完成后验证
  验证输出是否符合预期
  记录验证结果

整体验证:
  所有子任务完成后验证
  验证最终结果是否满足目标
  生成验证报告

回滚验证:
  回滚操作后验证
  确保系统状态正确
  记录回滚日志
```

---

## 四、常见任务分解模板

### 4.1 代码分析任务

```yaml
任务: 分析代码结构
分解:
  Step 1: 扫描目录结构
    工具: LS, Glob
    输出: 文件列表
    
  Step 2: 读取关键文件
    工具: Read
    输出: 文件内容
    
  Step 3: 分析代码结构
    工具: Grep, 分析逻辑
    输出: 结构分析
    
  Step 4: 生成分析报告
    工具: 格式化输出
    输出: 分析报告
```

### 4.2 代码重构任务

```yaml
任务: 重构代码
分解:
  Step 1: 分析现有代码
    工具: Read, Grep
    输出: 代码分析
    
  Step 2: 设计重构方案
    工具: 规划逻辑
    输出: 重构方案
    
  Step 3: 实施重构
    工具: Write, Edit
    输出: 重构后代码
    
  Step 4: 验证重构结果
    工具: 测试工具
    输出: 验证报告
    
  Step 5: 更新文档
    工具: Write
    输出: 更新后文档
```

### 4.3 问题诊断任务

```yaml
任务: 诊断问题
分解:
  Step 1: 收集信息
    工具: Read, Grep, LS
    输出: 问题信息
    
  Step 2: 分析可能原因
    工具: 分析逻辑
    输出: 原因列表
    
  Step 3: 验证假设
    工具: 测试工具
    输出: 验证结果
    
  Step 4: 定位根因
    工具: 分析逻辑
    输出: 根因分析
    
  Step 5: 提供解决方案
    工具: 规划逻辑
    输出: 解决方案
```

---

## 五、最佳实践

### 5.1 分解时机

```yaml
必须分解:
  - 任务复杂度 ≥ L3
  - 任务涉及多个工具
  - 任务有多个依赖关系
  - 任务风险较高

建议分解:
  - 任务复杂度 = L2
  - 任务需要多个步骤
  - 任务有不确定因素

可不分解:
  - 任务复杂度 = L1
  - 单一操作可完成
  - 目标明确无歧义
```

### 5.2 分解粒度

```yaml
粒度过粗:
  问题: 难以跟踪进度，错误定位困难
  解决: 进一步分解为更小单元

粒度过细:
  问题: 管理开销大，执行效率低
  解决: 合并相关子任务

合适粒度:
  标准: 每个子任务3-5步可完成
  验证: 每个子任务有明确输出
```

### 5.3 常见错误

```yaml
分解错误:
  漏掉关键步骤:
    后果: 任务无法完成
    预防: 完整性检查
    
  步骤重叠:
    后果: 重复工作，效率低
    预防: MECE原则检查
    
  依赖错误:
    后果: 执行顺序混乱
    预防: 依赖关系验证
    
  粒度不均:
    后果: 部分任务难以管理
    预防: 粒度一致性检查
```
