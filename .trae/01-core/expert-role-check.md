---
name: Expert Role Check
description: 专家角色检查触发器 - 复杂问题时自动触发专家角色模拟
version: "1.0"
priority: 90
alwaysApply: true
trigger: "on_complex_problem"
---

# 专家角色检查触发器

> **⚠️ 强制规则：复杂问题必须模拟专家角色分析**

---

## 一、触发条件

```yaml
触发场景:
  - 问题涉及专业领域知识
  - 需要多维度分析
  - 用户请求专家视角
  - 问题复杂度超过阈值

不触发场景:
  - 简单的代码修改
  - 明确的技术问题
  - 用户明确跳过
```

---

## 一点五、核心原则：独立分析框架优先 (重要)

> **⚠️ 关键原则：专家观点是参考，不是依赖；独立分析是核心，不是补充**

```yaml
核心理念:
  1. 自身分析框架优先: 必须先建立独立的分析框架和底层认知
  2. 专家观点是输入: 专家观点是分析输入之一，而非结论来源
  3. 辩证对待专家: 专家观点需要批判性思考，而非盲从
  4. 多源交叉验证: 专家观点需与数据、逻辑、历史交叉验证

⚠️ 禁止的错误做法:
  ❌ 直接引用专家观点作为结论
  ❌ 堆砌专家观点，缺乏独立分析
  ❌ 盲目相信专家，不进行批判性思考
  ❌ 专家观点与数据矛盾时，以专家为准

✅ 正确做法:
  ✅ 先建立独立分析框架
  ✅ 用专家观点补充视角，而非替代思考
  ✅ 对专家观点进行批判性分析
  ✅ 专家观点与数据矛盾时，以数据和逻辑为准
```

### 1.5.1 独立分析框架要求

```yaml
分析框架必须包含:
  1. 底层逻辑:
    - 问题的本质是什么？
    - 核心驱动因素是什么？
    - 因果关系如何建立？
  
  2. 关键变量识别:
    - 哪些变量是核心变量？
    - 变量之间的关联关系？
    - 变量的权重如何分配？
  
  3. 数据验证:
    - 有哪些客观数据支撑？
    - 数据是否可靠？
    - 数据趋势如何？
  
  4. 历史参照:
    - 历史上类似情况如何？
    - 有什么规律可循？
    - 本次有何不同？

示例 - 北京房价分析框架:
  底层逻辑:
    - 房价本质: 供需关系 + 货币因素 + 预期
    - 核心驱动: 人口流动、产业支撑、政策调控、库存水平
  
  关键变量:
    - 成交量 (权重30%): 市场活跃度指标
    - 库存 (权重25%): 供需平衡指标
    - 价格趋势 (权重20%): 市场预期指标
    - 政策 (权重15%): 外部干预因素
    - 人口 (权重10%): 长期需求支撑
  
  数据验证:
    - 网签数据: 官方权威
    - 挂牌量: 中介平台
    - 价格指数: 统计局/平台
  
  历史参照:
    - 2008-2017: 上涨周期
    - 2017-2025: 调整周期
    - 当前: 筑底阶段
```

### 1.5.2 辩证对待专家观点

```yaml
专家观点批判性分析:

Step 1: 理解专家观点
  - 专家的核心论点是什么？
  - 论据是什么？
  - 推理逻辑是什么？

Step 2: 验证专家观点
  - 观点是否有数据支撑？
  - 推理逻辑是否严密？
  - 是否存在利益关联？

Step 3: 对比分析
  - 与其他专家观点对比
  - 与客观数据对比
  - 与历史规律对比

Step 4: 批判性思考
  - 专家观点可能的盲点？
  - 专家观点的适用条件？
  - 专家观点的时效性？

Step 5: 独立判断
  - 是否采纳专家观点？
  - 采纳程度如何？
  - 与自身分析框架如何融合？

示例 - 对任泽平观点的批判性分析:
  专家观点: "2026年房地产上涨是大势所趋"
  
  Step 1 理解:
    - 论点: 2026年房价上涨
    - 论据: 三大信号(政策、经济、供需)
    - 逻辑: 信号出现→市场转折
  
  Step 2 验证:
    - 数据支撑: 成交量确实回升 ✅
    - 逻辑严密: 信号→转折的逻辑成立 ⚠️
    - 利益关联: 任泽平有流量需求 ⚠️
  
  Step 3 对比:
    - 其他专家: 谢逸枫、周金涛观点类似 ✅
    - 数据: 成交量回升、库存下降 ✅
    - 历史: 调整5-6年后通常企稳 ✅
  
  Step 4 批判:
    - 盲点: 未充分考虑经济下行风险
    - 条件: 仅适用于核心城市
    - 时效: 观点发布于2026年1月，需持续跟踪
  
  Step 5 判断:
    - 采纳程度: 70%
    - 理由: 数据支撑，但需警惕风险
    - 融合: 作为参考，结合自身分析框架
```

### 1.5.3 分析输出结构

```yaml
标准输出结构:
  1. 独立分析框架 (必须)
    - 底层逻辑
    - 关键变量
    - 数据验证
  
  2. 专家观点参考 (补充)
    - 专家观点摘要
    - 批判性分析
    - 采纳程度
  
  3. 综合判断 (核心)
    - 自身结论
    - 置信度
    - 风险提示
```

---

## 二、时效性检查（强制步骤）

> **⚠️ 重要：时效性敏感问题必须先获取当前时间**

### 2.1 时效性敏感场景识别

```yaml
时效性敏感场景:
  经济市场类:
    - 房地产价格趋势分析
    - 股票市场走势判断
    - 汇率变化预测
    - 商品价格分析
    - 利率政策影响
  
  政策法规类:
    - 最新政策解读
    - 法规变化影响
    - 监管动态分析
  
  技术发展类:
    - 技术趋势预测
    - 新技术影响评估
    - 行业变革分析
  
  国际形势类:
    - 地缘政治分析
    - 国际关系变化
    - 全球经济动态

非时效性敏感场景:
  - 代码架构设计
  - 算法原理讲解
  - 历史事件分析
  - 理论框架讨论
```

### 2.2 时效性检查流程

```yaml
Step 1: 获取当前时间
  动作: 
    - 从系统环境获取当前日期
    - 确认当前时间基准点
  输出: 
    - 当前日期: YYYY-MM-DD
    - 时间基准点明确

Step 2: 判断时效性敏感度
  动作:
    - 分析问题是否涉及时效性敏感场景
    - 评估信息时效性要求
  输出:
    - 时效性等级: 高/中/低
    - 信息有效期: 如"最近1个月"、"最近1年"

Step 3: 搜索最新信息（高时效性场景）
  动作:
    - 使用WebSearch获取最新信息
    - 搜索关键词包含当前年份
    - 优先获取权威来源的最新发布
  输出:
    - 最新数据/观点
    - 信息来源时间戳

Step 4: 标注信息时效性
  动作:
    - 在分析中明确标注信息时间
    - 说明信息的时效性限制
    - 提示可能的时效性风险
  输出:
    - 信息时间标注
    - 时效性风险提示
```

### 2.3 时效性标注规范

```yaml
标注格式:
  专家观点:
    格式: "任泽平 (2026年1月24日最新研判)"
    要求: 必须标注观点发布时间
  
  数据引用:
    格式: "2025年12月制造业PMI: 51.8%"
    要求: 必须标注数据统计时间
  
  预测判断:
    格式: "基于2026年2月最新信息判断"
    要求: 说明判断的时间基准
  
  时效性警告:
    格式: "⚠️ 本分析基于2026年2月信息，市场变化可能导致结论失效"
    要求: 高时效性场景必须添加警告
```

### 2.4 时效性检查示例

```yaml
示例问题: "分析北京房价未来趋势"

时效性检查执行:
  Step 1: 获取当前时间
    当前日期: 2026年2月17日
  
  Step 2: 判断时效性敏感度
    时效性等级: 高
    理由: 房地产市场变化快，政策频繁调整
  
  Step 3: 搜索最新信息
    搜索关键词: "任泽平 2026年 房地产 最新观点"
    搜索关键词: "2026年 康波周期 房地产"
    获取结果: 任泽平2026年1月24日最新研判
  
  Step 4: 标注信息时效性
    标注: "任泽平 (2026年1月24日最新研判)"
    警告: "⚠️ 房地产市场变化快，建议持续跟踪最新动态"

错误示例（缺少时效性检查）:
  ❌ 直接使用2024年或更早的专家观点
  ❌ 未标注观点发布时间
  ❌ 未说明分析的时间基准点
```

---

## 三、动态专家识别

### 3.1 识别原则

```yaml
核心原则:
  1. 动态解析: 根据问题内容实时识别所需专家
  2. 领域不限: 专家角色可以是任何领域
  3. 精准匹配: 只选择与分析相关的专家
  4. 灵活组合: 可同时调用多个专家协作

识别流程:
  1. 分析问题关键词
  2. 识别涉及的领域
  3. 确定需要的专家类型
  4. 评估专家数量和组合
```

### 3.2 领域识别规则

```yaml
领域识别方法:
  关键词匹配:
    示例:
      "房价、股市、通胀" → 经济领域
      "投资、风险、收益" → 金融领域
      "代码、架构、算法" → 软件领域
      "战略、安全、防御" → 军事领域
      "政策、外交、治理" → 政治领域
  
  语义理解:
    方法: 理解问题深层含义
    示例:
      "如何提高团队效率" → 管理领域 + 心理学领域
      "产品定价策略" → 市场营销领域 + 经济领域 + 心理学领域
  
  上下文关联:
    方法: 结合对话上下文
    示例:
      用户之前讨论技术 → 当前问题可能偏向技术视角
```

### 3.3 专家角色生成

```yaml
⚠️ 核心原则 - 动态生成优先:
  1. 专家角色必须根据问题特点动态生成，而非从预定义库中选取
  2. 预定义专家库仅作为参考示例，不是固定选择
  3. 每个问题都应该有其独特的专家组合
  4. 专家角色应该精准匹配问题的具体情境

专家角色定义模板:
  角色名称: [领域]专家
  核心能力: 该领域的专业知识和分析方法
  分析视角: 从该领域角度如何看待问题
  关注重点: 该领域最关注的要素
  典型方法: 该领域常用的分析工具和框架

动态生成流程:
  Step 1: 深度分析问题特点
    - 识别问题核心要素
    - 确定涉及的专业领域
    - 分析问题的独特情境
  
  Step 2: 搜索领域顶级专家 (关键步骤)
    - 使用WebSearch搜索该领域顶级专家
    - 搜索关键词: "[领域] 顶级专家 最新观点 [当前年份]"
    - 获取专家姓名、身份、核心理论、最新观点
    - 优先选择有明确理论体系的专家
  
  Step 3: 创建顶级专家角色 (非职能角色)
    - 专家角色必须是具体人物，而非职能描述
    - 包含: 专家姓名、身份、核心理论、分析框架
    - 模拟专家的思维方式和分析方法
  
  Step 4: 权重分配与融合
    - 根据问题特点分配专家权重
    - 融合多专家观点形成结论

⚠️ 专家角色类型区分 (重要):
  顶级专家角色 (正确):
    定义: 具体人物，有姓名、身份、核心理论
    示例: 
      - 任泽平 (前恒大首席经济学家，人口-金融-产业三维分析)
      - 周金涛 (康波周期理论创始人，50-60年周期嵌套)
      - Ray Dalio (桥水基金创始人，债务周期理论)
    特点: 有独特理论体系，观点可追溯验证
  
  职能角色 (禁止):
    定义: 抽象职能描述，无具体人物
    示例:
      ❌ 房地产市场分析师
      ❌ 宏观经济研究员
      ❌ 政策分析专家
    问题: 无理论体系，分析泛泛而谈，缺乏深度

动态生成示例:
  问题: "分析北京房价未来趋势"
  
  Step 1 分析问题特点:
    - 涉及经济周期、政策调控、市场供需
    - 需要宏观视角和微观分析结合
    - 时效性要求高
  
  Step 2 搜索顶级专家:
    搜索1: "任泽平 2026 房地产 最新观点"
      → 发现任泽平发布"2026年房地产上涨是大势所趋"
    搜索2: "周金涛 康波周期 房地产 2026"
      → 发现康波周期理论，2026年是回升期起点
    搜索3: "谢逸枫 2026 房地产 止跌回稳"
      → 发现谢逸枫判断"2026年房地产大拐点"
    搜索4: "中银证券 2026 房地产展望"
      → 发现机构报告"全年前低后高，两大拐点"
  
  Step 3 创建顶级专家角色:
    - 任泽平 (前恒大首席经济学家): 人口-金融-产业三维分析，判断"上涨是大势所趋"
    - 周金涛 (康波周期理论): 50-60年周期嵌套，2026年回升期起点
    - 谢逸枫 (房地产专家): 政策与市场分析，判断"大拐点来临"
    - 中银证券研究团队: 机构视角，预测"一季度政策拐点、四季度基本面拐点"
  
  Step 4 权重分配:
    - 任泽平: 35% (宏观策略权威)
    - 周金涛: 25% (周期理论创始人)
    - 谢逸枫: 20% (房地产专业)
    - 中银证券: 20% (机构研究)

错误示例 (禁止):
  ❌ 直接从预定义库选取: "任泽平、周金涛、孟晓苏" (不搜索最新观点)
  ❌ 固定使用相同专家组合
  ❌ 创建职能角色: "房地产市场分析师"、"宏观经济研究员"
  ❌ 不搜索最新观点直接使用历史观点

正确示例:
  ✅ 根据问题特点动态创建专家角色
  ✅ 搜索该领域当前最权威的专家观点
  ✅ 每次分析都有独特的专家组合
```

---

## 四、专家角色库（仅供参考，非固定选择）

### 4.1 常见领域专家（示例，仅供参考）

> **⚠️ 重要：以下专家仅作为参考示例，实际分析时应根据问题特点动态搜索和创建专家角色，而非直接从下方选取**

```yaml
顶级专家模拟原则:
  核心理念: 模拟具体领域顶级专家的思维框架和观点体系
  价值: 深度洞察、独特视角、方法论支撑
  要求: 理解专家的核心理论、分析框架、典型观点
  
  ⚠️ 时效性要求 (重要):
    1. 专家观点必须具有时效性，优先使用最近1年内的观点
    2. 对于时间敏感的问题(如经济、政策、市场)，必须搜索专家最新观点
    3. 标注观点来源时间，过时观点需明确说明可能已失效
    4. 专家观点可能随形势变化而调整，需动态跟踪
    5. 使用WebSearch工具获取专家最新公开发表的观点

商业经济类:
  翟东升 (宏观经济):
    身份: 中国人民大学国际关系学院教授
    核心理论: 货币权力理论、全球价值链分析
    分析框架: 从货币霸权、全球分工角度分析经济问题
    典型观点: 美元霸权周期、中国产业升级路径
    适用: 宏观经济、国际金融、产业政策
  
  周金涛 (康波周期):
    身份: 中信建投前首席经济学家
    核心理论: 康德拉季耶夫长波周期理论
    分析框架: 50-60年技术周期、资产价格波动规律
    典型观点: "人生发财靠康波"、周期嵌套理论
    适用: 资产配置、经济周期、投资时机
  
  任泽平 (宏观策略):
    身份: 前恒大首席经济学家
    核心理论: 宏观经济分析框架
    分析框架: 人口-金融-产业三维分析
    典型观点: "新5%比旧8%好"、房地产周期论
    适用: 宏观经济、房地产、政策分析
  
  刘煜辉 (金融宏观):
    身份: 中国社会科学院金融研究所研究员
    核心理论: 金融周期、货币分析
    分析框架: 信用周期、流动性分析
    典型观点: 金融去杠杆、风险定价
    适用: 金融市场、货币政策、风险分析

技术工程类:
  Martin Fowler (软件架构):
    身份: ThoughtWorks首席科学家
    核心理论: 企业架构模式、重构理论
    分析框架: 设计模式、架构演进
    典型观点: 微服务架构、持续集成
    适用: 软件架构、系统设计、技术演进
  
  Kent Beck (敏捷开发):
    身份: 极限编程创始人
    核心理论: XP、TDD、敏捷开发
    分析框架: 测试驱动、持续交付
    典型观点: "简单设计"、重构优先
    适用: 软件开发、团队协作、工程实践
  
  Linus Torvalds (系统设计):
    身份: Linux/Git创始人
    核心理论: 开源协作、分布式系统
    分析框架: 简单设计、社区驱动
    典型观点: "Talk is cheap, show me the code"
    适用: 系统设计、开源项目、技术决策

投资决策类:
  Ray Dalio (宏观经济投资):
    身份: 桥水基金创始人
    核心理论: 经济机器运行原理、债务周期
    分析框架: 债务周期、生产力增长、风险平价
    典型观点: "原则"体系、全天候策略
    适用: 宏观投资、资产配置、风险管理
  
  Warren Buffett (价值投资):
    身份: 伯克希尔哈撒韦CEO
    核心理论: 价值投资、护城河理论
    分析框架: 内在价值、安全边际、能力圈
    典型观点: "别人恐惧时贪婪"、长期持有
    适用: 股票投资、企业估值、长期策略
  
  Charlie Munger (多元思维):
    身份: 伯克希尔哈撒韦副董事长
    核心理论: 多元思维模型、逆向思考
    分析框架: 跨学科思维、lollapalooza效应
    典型观点: "反过来想，总是反过来想"
    适用: 投资决策、商业分析、思维模型

战略管理类:
  Michael Porter (竞争战略):
    身份: 哈佛商学院教授
    核心理论: 五力模型、竞争战略
    分析框架: 行业分析、竞争优势、价值链
    典型观点: 成本领先、差异化、聚焦
    适用: 企业战略、竞争分析、行业研究
  
  Clayton Christensen (创新理论):
    身份: 哈佛商学院教授
    核心理论: 颠覆式创新
    分析框架: 技术vs商业模式、低端颠覆
    典型观点: "创新者的窘境"
    适用: 创新战略、行业变革、企业转型

政治国际类:
  亨利·基辛格 (国际战略):
    身份: 前美国国务卿
    核心理论: 均势理论、现实主义外交
    分析框架: 地缘政治、大国博弈
    典型观点: 均势外交、战略耐心
    适用: 国际关系、地缘政治、外交策略
  
  阎学通 (国际关系):
    身份: 清华大学国际关系研究院院长
    核心理论: 道义现实主义
    分析框架: 权力转移、战略信誉
    典型观点: 中美关系、国际秩序演变
    适用: 国际政治、中美关系、安全战略

心理学类:
  Daniel Kahneman (行为经济学):
    身份: 诺贝尔经济学奖得主
    核心理论: 前景理论、快思考慢思考
    分析框架: 认知偏差、决策心理
    典型观点: 损失厌恶、锚定效应
    适用: 投资决策、消费行为、政策设计
  
  Robert Cialdini (影响力):
    身份: 亚利桑那州立大学教授
    核心理论: 影响力六大原则
    分析框架: 说服心理学、社会影响
    典型观点: 互惠、承诺一致、社会认同
    适用: 营销策略、用户行为、沟通说服
```

### 4.2 跨领域专家协作

```yaml
协作触发条件:
  - 问题涉及多个领域
  - 单一视角无法全面分析
  - 需要权衡不同利益
  - 问题复杂度高

协作模式:
  Blackboard模式:
    结构: 共享黑板 + 多个专家Agent
    流程:
      1. 各专家独立分析问题
      2. 将分析结果写入共享黑板
      3. 其他专家可以参考和评论
      4. 整合形成综合结论
  
  辩论模式:
    结构: 正方专家 vs 反方专家
    流程:
      1. 识别问题的不同立场
      2. 各专家代表不同立场辩论
      3. 权衡各方论据
      4. 形成平衡结论
  
  咨询模式:
    结构: 主专家 + 咨询专家
    流程:
      1. 主专家主导分析
      2. 遇到专业问题咨询相关专家
      3. 整合咨询意见
      4. 形成最终结论
```

---

## 五、实现示例

```python
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set
from enum import Enum
import re

class ExpertiseLevel(Enum):
    """专业程度"""
    PRIMARY = "primary"
    SECONDARY = "secondary"
    CONSULTANT = "consultant"

@dataclass
class ExpertRole:
    """专家角色"""
    name: str
    domain: str
    perspective: str
    methods: List[str]
    focus_areas: List[str]
    level: ExpertiseLevel = ExpertiseLevel.PRIMARY

@dataclass
class ExpertAnalysis:
    """专家分析结果"""
    expert: ExpertRole
    key_insights: List[str]
    recommendations: List[str]
    concerns: List[str]
    confidence: float

class DomainIdentifier:
    """领域识别器"""
    
    DOMAIN_KEYWORDS = {
        "经济": ["经济", "市场", "价格", "供需", "通胀", "GDP", "增长", "衰退"],
        "金融": ["投资", "股票", "基金", "风险", "收益", "利率", "融资"],
        "软件": ["代码", "架构", "算法", "系统", "开发", "测试", "部署"],
        "军事": ["战略", "战术", "安全", "防御", "武器", "冲突"],
        "政治": ["政策", "政府", "外交", "治理", "法规", "选举"],
        "心理": ["心理", "行为", "认知", "情感", "动机", "决策"],
        "社会": ["社会", "群体", "文化", "趋势", "人口", "城市化"],
        "技术": ["技术", "创新", "研发", "专利", "工程", "制造"],
        "环境": ["环境", "生态", "可持续", "污染", "资源", "气候"],
        "法律": ["法律", "合规", "合同", "权利", "义务", "法规"],
        "医学": ["健康", "疾病", "治疗", "医学", "药物", "临床"],
        "教育": ["教育", "学习", "培训", "课程", "教学", "知识"],
    }
    
    def identify_domains(self, question: str) -> List[str]:
        """识别问题涉及的领域"""
        domains = set()
        
        for domain, keywords in self.DOMAIN_KEYWORDS.items():
            for keyword in keywords:
                if keyword in question:
                    domains.add(domain)
                    break
        
        return list(domains)
    
    def calculate_relevance(self, question: str, domain: str) -> float:
        """计算领域相关性"""
        keywords = self.DOMAIN_KEYWORDS.get(domain, [])
        matches = sum(1 for kw in keywords if kw in question)
        return matches / len(keywords) if keywords else 0

class ExpertRoleGenerator:
    """专家角色生成器"""
    
    def generate_expert(self, domain: str, 
                       relevance: float,
                       question: str) -> ExpertRole:
        """动态生成专家角色"""
        
        expert_templates = {
            "经济": ExpertRole(
                name="经济学家",
                domain="经济",
                perspective="宏观经济规律和市场机制",
                methods=["经济模型分析", "数据分析", "趋势预测"],
                focus_areas=["供需关系", "价格机制", "经济周期"]
            ),
            "金融": ExpertRole(
                name="金融分析师",
                domain="金融",
                perspective="投资回报和风险评估",
                methods=["财务分析", "风险模型", "投资组合理论"],
                focus_areas=["收益率", "流动性", "风险控制"]
            ),
            "软件": ExpertRole(
                name="软件架构师",
                domain="软件",
                perspective="系统设计和技术实现",
                methods=["架构设计", "代码分析", "性能优化"],
                focus_areas=["可扩展性", "可维护性", "性能"]
            ),
            "军事": ExpertRole(
                name="军事战略家",
                domain="军事",
                perspective="战略规划和安全评估",
                methods=["战略分析", "威胁评估", "资源配置"],
                focus_areas=["战略优势", "安全风险", "资源效率"]
            ),
            "政治": ExpertRole(
                name="政治分析师",
                domain="政治",
                perspective="政策影响和权力结构",
                methods=["政策分析", "利益相关者分析", "趋势研判"],
                focus_areas=["政策走向", "利益平衡", "社会治理"]
            ),
            "心理": ExpertRole(
                name="心理学家",
                domain="心理",
                perspective="行为动机和认知过程",
                methods=["心理分析", "行为实验", "认知评估"],
                focus_areas=["用户心理", "决策过程", "情感因素"]
            ),
            "社会": ExpertRole(
                name="社会学家",
                domain="社会",
                perspective="社会结构和群体行为",
                methods=["社会调查", "统计分析", "趋势研究"],
                focus_areas=["社会趋势", "群体动态", "文化影响"]
            ),
            "技术": ExpertRole(
                name="技术专家",
                domain="技术",
                perspective="技术创新和工程实现",
                methods=["技术评估", "创新分析", "可行性研究"],
                focus_areas=["技术可行性", "创新价值", "实施路径"]
            ),
            "环境": ExpertRole(
                name="环境科学家",
                domain="环境",
                perspective="环境影响和可持续发展",
                methods=["环境评估", "生命周期分析", "影响预测"],
                focus_areas=["资源利用", "污染控制", "生态平衡"]
            ),
            "法律": ExpertRole(
                name="法律顾问",
                domain="法律",
                perspective="法律合规和风险防范",
                methods=["法律分析", "合规审查", "风险评估"],
                focus_areas=["法律风险", "合规要求", "权利义务"]
            ),
            "医学": ExpertRole(
                name="医学专家",
                domain="医学",
                perspective="健康影响和医疗方案",
                methods=["临床分析", "流行病学研究", "循证医学"],
                focus_areas=["健康风险", "治疗方案", "预防措施"]
            ),
            "教育": ExpertRole(
                name="教育专家",
                domain="教育",
                perspective="学习效果和知识传递",
                methods=["教学设计", "学习评估", "课程开发"],
                focus_areas=["学习效果", "知识传递", "能力培养"]
            ),
        }
        
        if domain in expert_templates:
            expert = expert_templates[domain]
            expert.level = (
                ExpertiseLevel.PRIMARY if relevance > 0.5
                else ExpertiseLevel.SECONDARY if relevance > 0.2
                else ExpertiseLevel.CONSULTANT
            )
            return expert
        
        return self._create_generic_expert(domain, question)
    
    def _create_generic_expert(self, domain: str, 
                               question: str) -> ExpertRole:
        """创建通用专家角色"""
        return ExpertRole(
            name=f"{domain}专家",
            domain=domain,
            perspective=f"从{domain}角度分析问题",
            methods=["专业分析", "案例研究", "经验判断"],
            focus_areas=["核心问题", "关键因素", "解决方案"]
        )

class ExpertSimulationEngine:
    """专家模拟引擎"""
    
    def __init__(self):
        self.domain_identifier = DomainIdentifier()
        self.expert_generator = ExpertRoleGenerator()
        self.blackboard: Dict = {}
    
    def analyze_with_experts(self, question: str) -> Dict:
        """使用专家角色分析问题"""
        
        domains = self.domain_identifier.identify_domains(question)
        
        if not domains:
            return {
                "need_experts": False,
                "reason": "未识别到特定领域，使用通用分析"
            }
        
        experts = []
        for domain in domains:
            relevance = self.domain_identifier.calculate_relevance(
                question, domain
            )
            expert = self.expert_generator.generate_expert(
                domain, relevance, question
            )
            experts.append(expert)
        
        experts.sort(key=lambda e: e.level.value)
        
        return {
            "need_experts": True,
            "domains": domains,
            "experts": [
                {
                    "name": e.name,
                    "domain": e.domain,
                    "perspective": e.perspective,
                    "methods": e.methods,
                    "focus_areas": e.focus_areas,
                    "level": e.level.value
                }
                for e in experts
            ],
            "collaboration_mode": self._determine_collaboration_mode(experts)
        }
    
    def _determine_collaboration_mode(self, 
                                     experts: List[ExpertRole]) -> str:
        """确定协作模式"""
        if len(experts) == 1:
            return "single"
        elif len(experts) == 2:
            return "debate"
        else:
            return "blackboard"
    
    def simulate_expert_analysis(self, 
                                expert: ExpertRole,
                                question: str) -> ExpertAnalysis:
        """模拟专家分析"""
        return ExpertAnalysis(
            expert=expert,
            key_insights=[f"从{expert.domain}角度的关键洞察"],
            recommendations=[f"基于{expert.domain}视角的建议"],
            concerns=[f"{expert.domain}层面的潜在风险"],
            confidence=0.8
        )
    
    def integrate_analyses(self, 
                          analyses: List[ExpertAnalysis]) -> Dict:
        """整合多个专家分析"""
        all_insights = []
        all_recommendations = []
        all_concerns = []
        
        for analysis in analyses:
            all_insights.extend(analysis.key_insights)
            all_recommendations.extend(analysis.recommendations)
            all_concerns.extend(analysis.concerns)
        
        return {
            "integrated_insights": all_insights,
            "integrated_recommendations": all_recommendations,
            "integrated_concerns": all_concerns,
            "consensus_level": self._calculate_consensus(analyses)
        }
    
    def _calculate_consensus(self, 
                            analyses: List[ExpertAnalysis]) -> float:
        """计算共识程度"""
        if not analyses:
            return 0.0
        return sum(a.confidence for a in analyses) / len(analyses)
```

---

## 六、使用流程

```yaml
标准流程:
  1. 问题分析:
     - 识别问题涉及的领域
     - 评估问题复杂度
     - 确定是否需要专家模拟
  
  2. 专家生成:
     - 根据领域动态生成专家角色
     - 确定专家专业程度
     - 选择协作模式
  
  3. 专家分析:
     - 各专家从专业视角分析
     - 输出关键洞察和建议
     - 识别潜在风险
  
  4. 结果整合:
     - 整合多专家分析结果
     - 识别共识和分歧
     - 形成综合结论

输出格式:
  专家分析报告:
    - 识别的领域
    - 调用的专家
    - 各专家分析结果
    - 整合结论
    - 置信度评估
```

---

## 七、检查清单

```yaml
触发检查:
  □ 问题是否涉及专业领域？
  □ 是否需要多维度分析？
  □ 问题复杂度是否超过阈值？

专家检查:
  □ 是否正确识别领域？
  □ 专家角色是否匹配？
  □ 协作模式是否合适？

分析检查:
  □ 各专家是否从专业视角分析？
  □ 分析是否全面深入？
  □ 是否识别了潜在风险？

整合检查:
  □ 是否整合了所有专家意见？
  □ 是否识别了共识和分歧？
  □ 结论是否平衡全面？
```

---

## 八、快速检查卡

```
┌─────────────────────────────────────────────┐
│           专家角色模拟速查表                 │
├─────────────────────────────────────────────┤
│                                             │
│  触发条件:                                   │
│    □ 涉及专业领域知识                       │
│    □ 需要多维度分析                         │
│    □ 用户请求专家视角                       │
│                                             │
│  动态识别:                                   │
│    关键词匹配 → 识别领域                    │
│    语义理解 → 确定专家                      │
│    上下文关联 → 优化匹配                    │
│                                             │
│  协作模式:                                   │
│    单专家: 单一领域问题                     │
│    辩论模式: 两方观点对比                   │
│    Blackboard: 多专家知识整合               │
│                                             │
│  输出内容:                                   │
│    专家视角 + 关键洞察 + 建议 + 风险        │
│                                             │
└─────────────────────────────────────────────┘
```

---

**记住**：专家角色动态生成，领域不限，精准匹配！

---

## 九、跨领域协作详细流程

### 9.1 协作流程步骤

```yaml
Step 1: 问题分解
  动作:
    - 识别问题的核心维度
    - 确定各维度涉及的领域
    - 评估各领域的重要性
  
  输出:
    - 问题维度列表
    - 领域重要性排序

Step 2: 专家团队组建
  动作:
    - 根据领域生成专家角色
    - 确定主专家和辅助专家
    - 分配专家权重
  
  输出:
    - 专家团队配置
    - 权重分配方案

Step 3: 独立分析阶段
  动作:
    - 各专家独立分析问题
    - 从专业视角输出见解
    - 记录分析依据
  
  输出:
    - 各专家独立分析报告

Step 4: 黑板共享阶段
  动作:
    - 将分析结果写入共享黑板
    - 标注关键发现和结论
    - 标记不确定性和假设
  
  输出:
    - 共享知识黑板

Step 5: 交叉评审阶段
  动作:
    - 专家相互审阅其他专家的分析
    - 提出质疑和补充
    - 发现潜在冲突点
  
  输出:
    - 交叉评审意见
    - 冲突点列表

Step 6: 冲突解决阶段
  动作:
    - 识别意见分歧点
    - 应用冲突解决机制
    - 达成共识或保留分歧
  
  输出:
    - 共识结论
    - 保留分歧点

Step 7: 结论整合阶段
  动作:
    - 整合所有专家意见
    - 加权计算最终结论
    - 生成综合报告
  
  输出:
    - 综合分析报告
    - 置信度评估
```

### 9.2 专家权重分配机制

```yaml
权重计算因素:
  领域相关性 (40%):
    高度相关: 1.0
    中度相关: 0.7
    低度相关: 0.4
    
  问题核心程度 (30%):
    核心领域: 1.0
    辅助领域: 0.6
    边缘领域: 0.3
    
  专家置信度 (20%):
    高置信: 1.0
    中置信: 0.7
    低置信: 0.4
    
  分析深度 (10%):
    深入分析: 1.0
    常规分析: 0.7
    浅层分析: 0.4

权重计算公式:
  W = 0.4 * 领域相关性 + 0.3 * 核心程度 + 0.2 * 置信度 + 0.1 * 分析深度

权重归一化:
  W_normalized = W_i / sum(W_all)

示例:
  问题: "分析北京房价未来趋势"
  
  专家权重计算:
    经济学家:
      领域相关性: 1.0 (核心)
      核心程度: 1.0 (核心)
      置信度: 0.9
      分析深度: 1.0
      W = 0.4*1.0 + 0.3*1.0 + 0.2*0.9 + 0.1*1.0 = 0.98
    
    政策分析师:
      领域相关性: 0.9 (高)
      核心程度: 0.8 (重要)
      置信度: 0.85
      分析深度: 0.9
      W = 0.4*0.9 + 0.3*0.8 + 0.2*0.85 + 0.1*0.9 = 0.86
    
    人口学家:
      领域相关性: 0.7 (中)
      核心程度: 0.6 (辅助)
      置信度: 0.8
      分析深度: 0.8
      W = 0.4*0.7 + 0.3*0.6 + 0.2*0.8 + 0.1*0.8 = 0.70
    
    归一化权重:
      经济学家: 0.98 / (0.98+0.86+0.70) = 0.39
      政策分析师: 0.86 / 2.54 = 0.34
      人口学家: 0.70 / 2.54 = 0.27
```

---

## 十、专家意见冲突解决

### 10.1 冲突类型识别

```yaml
结论冲突:
  定义: 专家对同一问题得出不同结论
  示例: 
    - 专家A认为房价上涨，专家B认为下跌
    - 专家A建议投资，专家B建议观望
  严重程度: 高

优先级冲突:
  定义: 专家对问题优先级排序不同
  示例:
    - 专家A认为政策因素最重要
    - 专家B认为经济因素最重要
  严重程度: 中

方法冲突:
  定义: 专家使用不同分析方法得出结论
  示例:
    - 专家A使用定量分析
    - 专家B使用定性分析
  严重程度: 低

假设冲突:
  定义: 专家基于不同假设前提
  示例:
    - 专家A假设政策稳定
    - 专家B假设政策可能变化
  严重程度: 中
```

### 10.2 冲突解决策略

```yaml
策略一: 权重投票
  适用: 结论冲突
  流程:
    1. 收集各专家结论
    2. 应用专家权重投票
    3. 选择权重最高的结论
  示例:
    结论A (权重0.39): 房价上涨
    结论B (权重0.34): 房价稳定
    结论C (权重0.27): 房价下跌
    结果: 房价上涨 (权重最高)

策略二: 概率融合
  适用: 预测类冲突
  流程:
    1. 获取各专家概率预测
    2. 加权平均计算综合概率
    3. 输出概率分布
  示例:
    专家A: 上涨概率60%
    专家B: 上涨概率40%
    专家C: 上涨概率30%
    综合: 0.39*0.6 + 0.34*0.4 + 0.27*0.3 = 44.7%

策略三: 场景分析
  适用: 假设冲突
  流程:
    1. 识别不同假设场景
    2. 各场景下分别分析
    3. 输出多场景结论
  示例:
    场景1 (政策稳定): 房价温和上涨
    场景2 (政策收紧): 房价持平
    场景3 (政策放松): 房价快速上涨

策略四: 协商整合
  适用: 优先级冲突
  流程:
    1. 各专家说明优先级理由
    2. 寻找共同点
    3. 整合形成综合优先级
  示例:
    专家A: 政策 > 经济 > 人口
    专家B: 经济 > 政策 > 供需
    整合: 政策=经济 > 供需 > 人口

策略五: 保留分歧
  适用: 无法达成共识
  流程:
    1. 明确记录分歧点
    2. 说明各方理由
    3. 提供用户决策建议
  示例:
    分歧点: 房价走势预测
    专家A观点: 上涨 (理由...)
    专家B观点: 下跌 (理由...)
    建议: 根据风险偏好选择
```

### 10.3 冲突解决实现

```python
class ConflictResolver:
    """专家意见冲突解决器"""
    
    def resolve_conclusion_conflict(self, 
                                   analyses: List[ExpertAnalysis],
                                   weights: Dict[str, float]) -> Dict:
        """解决结论冲突"""
        conclusions = {}
        
        for analysis in analyses:
            conclusion = analysis.key_insights[0] if analysis.key_insights else ""
            expert_name = analysis.expert.name
            weight = weights.get(expert_name, 0.5)
            
            if conclusion not in conclusions:
                conclusions[conclusion] = 0
            conclusions[conclusion] += weight
        
        best_conclusion = max(conclusions, key=conclusions.get)
        
        return {
            "method": "weighted_voting",
            "conclusion": best_conclusion,
            "confidence": conclusions[best_conclusion],
            "all_conclusions": conclusions
        }
    
    def resolve_probability_conflict(self,
                                    predictions: Dict[str, float],
                                    weights: Dict[str, float]) -> Dict:
        """解决概率预测冲突"""
        weighted_sum = 0
        total_weight = 0
        
        for expert, prob in predictions.items():
            weight = weights.get(expert, 0.5)
            weighted_sum += prob * weight
            total_weight += weight
        
        return {
            "method": "probability_fusion",
            "integrated_probability": weighted_sum / total_weight if total_weight else 0,
            "individual_predictions": predictions
        }
    
    def resolve_by_scenario(self,
                           scenarios: Dict[str, List[ExpertAnalysis]]) -> Dict:
        """场景分析解决"""
        results = {}
        
        for scenario, analyses in scenarios.items():
            insights = []
            for a in analyses:
                insights.extend(a.key_insights)
            results[scenario] = insights
        
        return {
            "method": "scenario_analysis",
            "scenarios": results,
            "recommendation": "根据最可能场景决策"
        }
```

---

## 十一、实际案例分析

### 11.1 案例一：北京房价趋势分析

```yaml
问题: "分析北京房价未来5年趋势"

领域识别:
  - 经济 (相关性: 0.9)
  - 政策 (相关性: 0.85)
  - 人口 (相关性: 0.7)
  - 城市规划 (相关性: 0.6)

专家团队:
  主专家:
    - 经济学家 (权重: 0.35)
    - 政策分析师 (权重: 0.30)
  辅助专家:
    - 人口学家 (权重: 0.20)
    - 城市规划师 (权重: 0.15)

协作流程:
  1. 经济学家分析:
     - 供需关系: 供给受限，需求稳定
     - 经济周期: 处于调整期
     - 结论: 温和上涨概率60%
  
  2. 政策分析师分析:
     - 调控政策: 持续收紧
     - 土地供应: 稳定增加
     - 结论: 持平概率55%
  
  3. 人口学家分析:
     - 人口流入: 放缓趋势
     - 老龄化: 加速
     - 结论: 下行压力增大
  
  4. 城市规划师分析:
     - 副中心建设: 分流需求
     - 交通发展: 扩大通勤圈
     - 结论: 区域分化明显

冲突解决:
  冲突点: 房价走势判断
  解决方法: 概率融合
  综合结论:
    - 温和上涨概率: 35%*0.6 + 30%*0.45 + 20%*0.3 + 15%*0.4 = 46%
    - 持平概率: 38%
    - 下跌概率: 16%

最终结论:
  北京房价未来5年大概率温和上涨或持平，
  区域分化明显，核心区抗跌性强。
```

### 11.2 案例二：企业技术选型决策

```yaml
问题: "选择企业数据库技术栈"

领域识别:
  - 软件架构 (相关性: 1.0)
  - 成本 (相关性: 0.8)
  - 安全 (相关性: 0.7)
  - 运维 (相关性: 0.6)

专家团队:
  主专家:
    - 软件架构师 (权重: 0.40)
    - 成本分析师 (权重: 0.25)
  辅助专家:
    - 安全专家 (权重: 0.20)
    - 运维专家 (权重: 0.15)

协作流程:
  1. 架构师分析:
     - 方案A (PostgreSQL): 成熟稳定，生态完善
     - 方案B (MySQL): 简单易用，社区活跃
     - 方案C (MongoDB): 灵活，适合非结构化数据
     - 推荐: PostgreSQL
  
  2. 成本分析师分析:
     - 方案A: 许可免费，运维成本中等
     - 方案B: 许可免费，运维成本低
     - 方案C: 许可免费，运维成本高
     - 推荐: MySQL
  
  3. 安全专家分析:
     - 方案A: 安全特性完善
     - 方案B: 安全特性基本
     - 方案C: 需额外配置
     - 推荐: PostgreSQL
  
  4. 运维专家分析:
     - 方案A: 运维复杂度中等
     - 方案B: 运维简单
     - 方案C: 运维复杂
     - 推荐: MySQL

冲突解决:
  冲突点: PostgreSQL vs MySQL
  解决方法: 权重投票
  PostgreSQL: 0.40 + 0.20 = 0.60
  MySQL: 0.25 + 0.15 = 0.40
  
最终结论:
  推荐PostgreSQL，但需关注运维成本控制
```

### 11.3 案例三：新产品市场策略

```yaml
问题: "制定新产品市场推广策略"

领域识别:
  - 市场营销 (相关性: 1.0)
  - 消费者心理 (相关性: 0.9)
  - 竞争分析 (相关性: 0.8)
  - 财务 (相关性: 0.6)

专家团队:
  主专家:
    - 营销专家 (权重: 0.35)
    - 心理学家 (权重: 0.25)
  辅助专家:
    - 竞争分析师 (权重: 0.25)
    - 财务分析师 (权重: 0.15)

协作模式: Blackboard

黑板内容:
  市场洞察:
    - 目标用户画像
    - 市场规模估算
    - 渠道选择建议
  
  心理洞察:
    - 用户决策因素
    - 情感触发点
    - 信任建立机制
  
  竞争洞察:
    - 竞品分析
    - 差异化机会
    - 市场定位建议
  
  财务洞察:
    - 预算分配建议
    - ROI预测
    - 风险评估

整合结论:
  策略组合:
    1. 精准定位差异化卖点
    2. 情感化内容营销
    3. 分阶段预算投入
    4. 持续监测竞品动态
```

---

## 十二、跨领域协作检查清单

```yaml
协作前检查:
  □ 是否正确识别所有相关领域？
  □ 专家团队配置是否合理？
  □ 权重分配是否公平？

协作中检查:
  □ 各专家是否独立分析？
  □ 黑板信息是否完整共享？
  □ 交叉评审是否充分？

冲突处理检查:
  □ 是否识别所有冲突点？
  □ 冲突解决方法是否合适？
  □ 是否保留必要分歧？

整合检查:
  □ 是否整合所有专家意见？
  □ 权重计算是否正确？
  □ 结论是否平衡全面？
```
