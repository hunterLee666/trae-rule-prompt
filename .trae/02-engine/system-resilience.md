---
name: System Resilience Rules
description: 系统韧性规则 - 熔断降级、重试策略、限流超时、极端场景处理
version: "9.7"
priority: 90
alwaysApply: true
---

# 系统韧性规则

> **"系统有韧性，服务有保障。"**

## 一、熔断机制

### 1.1 熔断器状态

```yaml
状态机:
  Closed (关闭):
    条件: 正常状态
    行为: 所有请求正常通过
    转换: 错误率超过阈值 → Open
    
  Open (打开):
    条件: 熔断状态
    行为: 所有请求快速失败
    转换: 超时后 → Half-Open
    
  Half-Open (半开):
    条件: 探测状态
    行为: 允许部分请求通过
    转换: 
      成功 → Closed
      失败 → Open
```

### 1.2 熔断配置

```yaml
熔断参数:
  错误率阈值: 50%
  最小请求数: 10
  熔断时长: 30s
  半开请求数: 3
  
熔断规则:
  服务熔断:
    条件: 下游服务不可用
    动作: 返回降级响应
    
  数据库熔断:
    条件: 数据库连接失败
    动作: 返回缓存数据
    
  API熔断:
    条件: 外部API超时
    动作: 返回默认值或错误
```

### 1.3 降级策略

```yaml
降级类型:
  返回默认值:
    场景: 非核心功能
    示例: 推荐服务 → 返回热门列表
    
  返回缓存:
    场景: 数据查询
    示例: 用户信息 → 返回缓存数据
    
  关闭功能:
    场景: 可选功能
    示例: 评论功能 → 显示"暂时不可用"
    
  限流保护:
    场景: 高负载
    示例: 秒杀活动 → 排队等待
```

---

## 二、重试策略

### 2.1 重试配置

```yaml
重试参数:
  最大重试次数: 3
  初始间隔: 100ms
  最大间隔: 10s
  间隔倍数: 2
  抖动因子: 0.1

重试条件:
  可重试错误:
    - NetworkError
    - TimeoutError
    - ServiceUnavailable
    - TooManyRequests
    
  不可重试错误:
    - BadRequest
    - Unauthorized
    - Forbidden
    - NotFound
```

### 2.2 重试模式

```yaml
固定间隔:
  策略: 每次间隔相同时间
  适用: 简单场景
  示例: 1s, 1s, 1s

指数退避:
  策略: 间隔指数增长
  适用: 网络错误
  示例: 1s, 2s, 4s, 8s

抖动退避:
  策略: 间隔加随机抖动
  适用: 分布式系统
  示例: 1s±0.1s, 2s±0.2s

装饰器模式:
  策略: 每次重试执行额外操作
  适用: 需要清理状态
  示例: 重试前清理连接池
```

---

## 三、限流机制

### 3.1 限流算法

```yaml
固定窗口:
  实现: 在固定时间窗口内计数
  优点: 实现简单
  缺点: 边界突发问题
  示例: 每分钟100次请求

滑动窗口:
  实现: 滑动时间窗口计数
  优点: 更平滑
  缺点: 内存占用较高
  示例: 任意1分钟内100次请求

令牌桶:
  实现: 以固定速率生成令牌
  优点: 允许突发流量
  缺点: 需要维护令牌状态
  示例: 每秒10个令牌，桶容量100

漏桶:
  实现: 以固定速率处理请求
  优点: 流量平滑
  缺点: 无法应对突发
  示例: 每秒处理10个请求
```

### 3.2 限流配置

```yaml
API限流:
  全局限流: 10000 QPS
  单用户限流: 100 QPS
  单IP限流: 1000 QPS
  
服务限流:
  核心服务: 优先保障
  非核心服务: 可降级
  
数据库限流:
  连接池: 100连接
  查询超时: 5s
  慢查询阈值: 1s
```

### 3.3 限流响应

```yaml
限流响应:
  HTTP 429:
    状态码: 429 Too Many Requests
    响应头: 
      X-RateLimit-Limit: 100
      X-RateLimit-Remaining: 0
      X-RateLimit-Reset: 1234567890
    响应体:
      {
        "error": "rate_limit_exceeded",
        "message": "Too many requests",
        "retry_after": 60
      }
```

---

## 四、超时控制

### 4.1 超时类型

```yaml
连接超时:
  定义: 建立连接的超时时间
  默认值: 5s
  建议: 根据网络环境调整

读取超时:
  定义: 等待响应的超时时间
  默认值: 30s
  建议: 根据操作复杂度调整

写入超时:
  定义: 发送数据的超时时间
  默认值: 30s
  建议: 根据数据大小调整

总超时:
  定义: 整个操作的总时间
  默认值: 60s
  建议: 设置合理上限
```

### 4.2 超时配置

```yaml
API超时:
  快速API: 1s
  普通API: 5s
  慢速API: 30s
  
数据库超时:
  简单查询: 100ms
  复杂查询: 5s
  批量操作: 60s
  
外部服务超时:
  第三方API: 10s
  支付网关: 30s
  消息队列: 5s
```

### 4.3 超时处理

```yaml
超时处理策略:
  重试:
    条件: 幂等操作
    动作: 按重试策略执行
    
  降级:
    条件: 非关键操作
    动作: 返回降级响应
    
  失败:
    条件: 关键操作
    动作: 返回错误，记录日志
```

---

## 五、隔离机制

### 5.1 隔离策略

```yaml
舱壁隔离:
  原理: 将资源划分为独立舱室
  实现: 
    - 线程池隔离
    - 进程隔离
    - 容器隔离
  效果: 单点故障不影响全局

服务隔离:
  核心服务: 独立部署
  非核心服务: 共享资源
  效果: 非核心故障不影响核心

数据隔离:
  热数据: 高性能存储
  冷数据: 低成本存储
  效果: 数据访问互不影响
```

### 5.2 资源隔离

```yaml
线程池隔离:
  核心服务: 独立线程池
  非核心服务: 共享线程池
  配置:
    核心线程数: 10
    最大线程数: 50
    队列容量: 100

连接池隔离:
  数据库: 独立连接池
  外部服务: 独立连接池
  配置:
    最小连接数: 5
    最大连接数: 20
    连接超时: 5s
```

---

## 六、健康检查

### 6.1 健康检查类型

```yaml
存活检查:
  目的: 检查进程是否存活
  方式: /health/live
  频率: 每10s
  失败处理: 重启容器

就绪检查:
  目的: 检查服务是否就绪
  方式: /health/ready
  频率: 每5s
  失败处理: 暂停流量

启动检查:
  目的: 检查服务是否启动完成
  方式: /health/startup
  频率: 启动时
  失败处理: 等待或重启
```

### 6.2 健康检查内容

```yaml
检查项:
  基础检查:
    - 进程状态
    - 内存使用
    - CPU使用
    
  依赖检查:
    - 数据库连接
    - 缓存连接
    - 消息队列连接
    
  业务检查:
    - 关键接口可用
    - 后台任务正常
    - 定时任务正常

响应格式:
  {
    "status": "healthy",
    "checks": {
      "database": "ok",
      "cache": "ok",
      "api": "ok"
    },
    "timestamp": "2024-01-15T10:30:00Z"
  }
```

---

## 七、极端场景处理

### 7.1 资源耗尽场景

```yaml
内存不足:
  检测: 内存使用 > 90%
  处理:
    1. 释放非必要缓存
    2. 拒绝新请求
    3. 执行垃圾回收
    4. 通知管理员
  降级: 使用最小内存模式运行

磁盘空间不足:
  检测: 磁盘使用 > 90%
  处理:
    1. 清理临时文件
    2. 压缩日志文件
    3. 删除过期缓存
    4. 通知管理员
  降级: 禁用文件写入功能

CPU过载:
  检测: CPU使用 > 90%
  处理:
    1. 降低任务优先级
    2. 延迟非关键任务
    3. 限制并发数
    4. 通知管理员
  降级: 仅处理关键任务

连接池耗尽:
  检测: 空闲连接 = 0
  处理:
    1. 等待连接释放
    2. 拒绝新请求
    3. 扩大连接池
  降级: 排队等待模式
```

### 7.2 网络故障场景

```yaml
完全断网:
  检测: 所有网络请求失败
  处理:
    1. 切换到离线模式
    2. 使用本地缓存
    3. 队列化请求
    4. 定期重试连接
  降级: 仅提供本地功能

部分网络故障:
  检测: 部分服务不可达
  处理:
    1. 标记故障服务
    2. 使用备用服务
    3. 启用熔断器
  降级: 禁用依赖故障服务的功能

DNS解析失败:
  检测: DNS查询超时或失败
  处理:
    1. 使用缓存IP
    2. 使用备用DNS
    3. 使用硬编码IP
  降级: 使用已知IP直连

SSL证书错误:
  检测: 证书验证失败
  处理:
    1. 检查证书有效期
    2. 更新证书
    3. 通知管理员
  降级: 不建议跳过验证
```

### 7.3 服务故障场景

```yaml
数据库故障:
  检测: 连接失败或查询超时
  处理:
    1. 使用读副本
    2. 返回缓存数据
    3. 启用熔断器
  降级: 只读模式或缓存模式

缓存故障:
  检测: 缓存连接失败
  处理:
    1. 直接查询数据库
    2. 使用本地缓存
    3. 限流保护数据库
  降级: 无缓存模式，性能下降

消息队列故障:
  检测: 队列连接失败
  处理:
    1. 使用本地队列
    2. 同步处理
    3. 记录待发送消息
  降级: 同步处理模式

外部API故障:
  检测: API调用失败
  处理:
    1. 使用备用API
    2. 返回缓存数据
    3. 返回默认值
  降级: 禁用依赖功能
```

### 7.4 数据异常场景

```yaml
数据损坏:
  检测: 数据校验失败
  处理:
    1. 从备份恢复
    2. 使用缓存数据
    3. 通知管理员
  降级: 使用历史数据

数据不一致:
  检测: 数据版本冲突
  处理:
    1. 使用最新版本
    2. 合并冲突数据
    3. 通知用户确认
  降级: 使用主数据源

数据丢失:
  检测: 预期数据不存在
  处理:
    1. 从备份恢复
    2. 重新计算
    3. 使用默认值
  降级: 提示用户重新输入

数据格式错误:
  检测: 解析失败
  处理:
    1. 尝试修复格式
    2. 使用宽松解析
    3. 记录原始数据
  降级: 跳过错误数据
```

### 7.5 极端场景处理清单

```yaml
资源检查:
  - [ ] 内存使用监控
  - [ ] 磁盘空间监控
  - [ ] CPU使用监控
  - [ ] 连接池状态监控

网络检查:
  - [ ] 网络连通性检测
  - [ ] DNS解析检测
  - [ ] SSL证书检测
  - [ ] 延迟监控

服务检查:
  - [ ] 数据库健康检查
  - [ ] 缓存健康检查
  - [ ] 消息队列健康检查
  - [ ] 外部API健康检查

数据检查:
  - [ ] 数据完整性校验
  - [ ] 数据一致性检查
  - [ ] 数据备份验证
  - [ ] 数据格式验证

降级预案:
  - [ ] 离线模式预案
  - [ ] 只读模式预案
  - [ ] 缓存模式预案
  - [ ] 最小功能模式预案
```
