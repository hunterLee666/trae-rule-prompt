---
name: Multi-Agent Collaboration Rules
description: 多Agent协作规则 - 协作模式、通信协议、冲突解决、任务分配
version: "9.2"
priority: 90
alwaysApply: true
---

# 多Agent协作规则

> **"独木不成林，单丝不成线。"**

## 一、协作模式选择

### 1.1 模式分类

```yaml
Master-Slave模式:
  结构: 1个主Agent + N个从Agent
  特点: 集中控制，任务分发
  适用: 明确的层级任务
  示例: 代码审查（主Agent分配审查任务）

Peer-to-Peer模式:
  结构: N个对等Agent
  特点: 平等协作，相互通信
  适用: 无明确主次的任务
  示例: 头脑风暴、创意协作

Pipeline模式:
  结构: Agent1 → Agent2 → Agent3 → ...
  特点: 流水线处理，顺序执行
  适用: 有明确流程的任务
  示例: 代码编写→审查→优化

Blackboard模式:
  结构: 共享黑板 + 多个专家Agent
  特点: 知识共享，异步协作
  适用: 需要知识整合的任务
  示例: 复杂问题诊断

Contract Net模式:
  结构: 任务发布 + 竞标执行
  特点: 动态分配，能力匹配
  适用: 任务类型多样的场景
  示例: 多技能任务分配

Coalition模式:
  结构: 动态联盟，临时组队
  特点: 灵活组合，按需协作
  适用: 复杂多变的环境
  示例: 应急响应系统
```

### 1.2 模式选择指南

```yaml
决策因素:
  任务复杂度:
    简单: Master-Slave
    中等: Pipeline
    复杂: Coalition
  
  Agent数量:
    2-3个: Peer-to-Peer
    4-10个: Pipeline或Blackboard
    10+个: Contract Net
  
  任务依赖:
    独立: Peer-to-Peer
    顺序: Pipeline
    复杂: Blackboard
  
  时间约束:
    宽松: Contract Net
    紧急: Master-Slave

选择流程:
  1. 评估任务复杂度
  2. 确定Agent数量
  3. 分析任务依赖关系
  4. 考虑时间约束
  5. 选择最匹配的模式
```

---

## 二、通信协议

### 2.1 消息格式

```yaml
标准消息结构:
  header:
    message_id: UUID
    timestamp: ISO8601
    sender: Agent名称
    receiver: Agent名称 | "broadcast"
    message_type: request | response | notification | error
  
  body:
    content: 消息内容
    context: 上下文信息
    metadata: 元数据
  
  footer:
    priority: high | medium | low
    ttl: 消息有效期(秒)
    requires_response: true | false

示例:
  header:
    message_id: "msg-001"
    timestamp: "2024-01-15T10:30:00Z"
    sender: "WriterAgent"
    receiver: "ReviewerAgent"
    message_type: "request"
  
  body:
    content: "请审查以下代码..."
    context:
      task_id: "task-123"
      code_file: "main.py"
    metadata:
      code_lines: 50
      language: "python"
  
  footer:
    priority: "medium"
    ttl: 3600
    requires_response: true
```

### 2.2 通信模式

```yaml
同步通信:
  模式: 请求-响应
  特点: 阻塞等待
  适用: 需要即时反馈的场景
  
  流程:
    AgentA --request--> AgentB
    AgentA <--response-- AgentB
  
  超时处理:
    默认超时: 30秒
    超时行为: 重试或降级

异步通信:
  模式: 消息队列
  特点: 非阻塞
  适用: 不需要即时反馈的场景
  
  流程:
    AgentA --message--> Queue
    AgentB <--message-- Queue
  
  消息保证:
    至少一次投递
    消息顺序保证

广播通信:
  模式: 发布-订阅
  特点: 一对多
  适用: 状态通知、事件广播
  
  流程:
    AgentA --broadcast--> [AgentB, AgentC, AgentD]
  
  订阅机制:
    主题订阅
    模式匹配
```

### 2.3 通信优化

```yaml
消息压缩:
  触发条件: 消息大小 > 1KB
  压缩算法: gzip
  压缩率目标: > 50%

批量发送:
  触发条件: 消息数量 > 10
  批量大小: 100条/批
  延迟: 100ms

消息缓存:
  缓存策略: LRU
  缓存大小: 1000条
  过期时间: 1小时

流量控制:
  限流策略: 令牌桶
  速率限制: 100条/秒
  突发限制: 500条
```

---

## 三、任务分配

### 3.1 任务分类

```yaml
按类型分类:
  代码任务:
    子类: 编写、审查、优化、测试
    技能要求: 编程能力、代码理解
  
  分析任务:
    子类: 数据分析、问题诊断、架构分析
    技能要求: 分析能力、领域知识
  
  创作任务:
    子类: 文档编写、内容创作、方案设计
    技能要求: 写作能力、创意思维
  
  协调任务:
    子类: 任务分配、进度跟踪、冲突调解
    技能要求: 沟通能力、组织能力

按优先级分类:
  紧急: 需要立即处理
  高: 需要优先处理
  中: 正常处理
  低: 可延后处理

按复杂度分类:
  简单: 单一操作
  中等: 多步骤
  复杂: 多模块协作
  超复杂: 开放式问题
```

### 3.2 能力评估

```yaml
评估维度:
  专业技能:
    代码能力: 1-10分
    分析能力: 1-10分
    创作能力: 1-10分
    协调能力: 1-10分
  
  历史表现:
    任务完成率: 百分比
    平均完成时间: 分钟
    质量评分: 1-10分
  
  当前状态:
    负载: 低/中/高
    可用性: 空闲/忙碌/离线
    专长匹配度: 百分比

综合评分:
  公式: 
    Score = w1*专业技能 + w2*历史表现 + w3*当前状态
  权重:
    w1: 0.4
    w2: 0.3
    w3: 0.3
```

### 3.3 分配算法

```yaml
贪心算法:
  策略: 每次选择最优Agent
  适用: 简单任务分配
  复杂度: O(n*m)
  
  流程:
    1. 获取待分配任务
    2. 计算所有Agent得分
    3. 选择得分最高的Agent
    4. 更新Agent状态

匈牙利算法:
  策略: 全局最优匹配
  适用: 多任务多Agent匹配
  复杂度: O(n^3)
  
  流程:
    1. 构建任务-Agent得分矩阵
    2. 应用匈牙利算法
    3. 获取最优分配方案

负载均衡算法:
  策略: 平衡Agent负载
  适用: 长期运行系统
  复杂度: O(n)
  
  流程:
    1. 计算各Agent当前负载
    2. 选择负载最低的合适Agent
    3. 分配任务
    4. 更新负载状态
```

---

## 四、冲突解决

### 4.1 冲突类型

```yaml
意见分歧:
  场景: 多Agent对同一问题有不同看法
  示例: 代码风格选择、技术方案选择
  影响: 决策延迟

资源竞争:
  场景: 多Agent竞争同一资源
  示例: 文件写入、API调用限制
  影响: 执行阻塞

任务冲突:
  场景: 任务分配或执行出现冲突
  示例: 重复任务、依赖冲突
  影响: 资源浪费

目标冲突:
  场景: Agent目标不一致
  示例: 效率vs质量、速度vs安全
  影响: 结果偏离预期
```

### 4.2 解决策略

```yaml
协商策略:
  适用: 意见分歧
  流程:
    1. 各Agent陈述理由
    2. 分析各方论据
    3. 寻找共同点
    4. 达成妥协方案
  超时: 5分钟
  失败处理: 进入投票

投票策略:
  适用: 协商失败
  流程:
    1. 收集所有选项
    2. 各Agent投票
    3. 统计票数
    4. 选择多数票选项
  平票处理: 仲裁

仲裁策略:
  适用: 投票平票或紧急情况
  流程:
    1. 提交仲裁请求
    2. 仲裁Agent分析
    3. 做出最终决定
  仲裁Agent: 指定的协调Agent

升级策略:
  适用: 所有策略失败
  流程:
    1. 记录冲突详情
    2. 通知人类用户
    3. 等待用户决策
  响应时间: 用户决定
```

### 4.3 冲突预防

```yaml
事前预防:
  明确分工: 清晰定义Agent职责边界
  优先级规则: 预设任务优先级
  资源预约: 提前预约共享资源
  协议约定: 统一通信和协作协议

事中监控:
  状态检测: 实时检测冲突信号
  预警机制: 冲突风险预警
  自动调解: 轻微冲突自动处理

事后分析:
  冲突记录: 详细记录冲突信息
  原因分析: 分析冲突根本原因
  规则优化: 优化预防规则
```

---

## 五、协作最佳实践

### 5.1 协作原则

```yaml
明确性原则:
  角色明确: 每个Agent职责清晰
  目标明确: 任务目标具体可衡量
  流程明确: 协作步骤标准化

高效性原则:
  最少通信: 减少不必要的消息
  并行执行: 独立任务并行处理
  缓存复用: 避免重复计算

鲁棒性原则:
  容错设计: 单点故障不影响整体
  降级策略: 部分失败可降级运行
  恢复机制: 故障后可快速恢复

可扩展性原则:
  模块化: Agent可独立扩展
  松耦合: Agent间依赖最小化
  标准接口: 统一接口规范
```

### 5.2 常见问题解决

```yaml
通信延迟:
  问题: Agent间通信延迟高
  解决: 
    - 使用异步通信
    - 本地缓存数据
    - 批量发送消息

任务积压:
  问题: 任务队列积压
  解决:
    - 动态增加Agent
    - 任务优先级排序
    - 任务合并优化

状态不一致:
  问题: Agent状态不同步
  解决:
    - 定期状态同步
    - 使用共享状态存储
    - 实现状态版本控制

死锁:
  问题: Agent相互等待
  解决:
    - 设置超时机制
    - 实现死锁检测
    - 设计回退策略
```
